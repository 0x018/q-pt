import * as std from 'std';
import * as os from 'os';
// import { file } from "./fsys/file.js";
const config = {
	temp: "./temp/",
	qjsh: "/usr/local/include/quickjs/",
	qjslib: "/usr/local/lib/quickjs/",
	clib: '../clib/', // from temp;
	cfun: './cfun/',
}
let file = (src) => {
	let fdo = (mode, fun) => { let f = std.open(src, mode); let d = fun(f); f.close(); return d; }
	return {
		read() { return fdo("r", (fd) => fd.readAsString()); },
		write(str) { fdo("w", (fd) => fd.puts(str)); }
	}
};

let fileName = (os.readdir(config.cfun)[0]).filter(v => /\.c$/.test(v)).map(v => config.cfun + v);
let clr = {
	esc: String.fromCharCode(27),
	red: (str) => clr.esc + "[37;41m " + str + " " + clr.esc + "[0m",
	blue: (str) => clr.esc + "[37;46m " + str + " " + clr.esc + "[0m",
	green: (str) => clr.esc + "[37;42m " + str + " " + clr.esc + "[0m",
}
// "-f", "./*.c", "./*.h"
os.exec(["rm", "-rf", config.temp]);
os.mkdir(config.temp);
os.exec(["cp", `${config.qjsh}quickjs.h`, config.temp]);
os.exec(["cp", `${config.qjsh}quickjs-libc.h`, config.temp]);

console.log(clr.blue("build"), "cfun files:", fileName);
if (!fileName || !fileName.length) std.exit();
function code(info, text, name) {
	return `/* Code generated by cfun.js */\n#include "quickjs.h"\n` +
		`#define export static\n` +

		`${text}\n` +
		`#define JS_INIT_MODULE js_init_module\n` +
		`#define countof(x) (sizeof(x) / sizeof((x)[0]))\n` +
		info.map(code =>
			`static JSValue js_${code.name}(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)\n` +
			`{\n` +
			`${code.jsvalue}\n` +
			`}\n\n\n`).join("\n") + "\n" +

		`static const JSCFunctionListEntry js_${name}_funcs[] = {\n` +
		info.map(code =>
			`  JS_CFUNC_DEF("${code.name}", ${code.argLen}, js_${code.name}),\n`).join("") +
		`};\n` +
		`static int js_${name}_init(JSContext *ctx, JSModuleDef *m)\n` +
		`{\n` +
		`  return JS_SetModuleExportList(ctx, m, js_${name}_funcs, countof(js_${name}_funcs));\n` +
		`}\n` +
		`JSModuleDef *JS_INIT_MODULE(JSContext *ctx, const char *module_name)\n` +
		`{\n` +
		`  JSModuleDef *m;\n` +
		`  m = JS_NewCModule(ctx, module_name, js_${name}_init);\n` +
		`  if (!m)\n` +
		`    return NULL;\n` +
		`  JS_AddModuleExportList(ctx, m, js_${name}_funcs, countof(js_${name}_funcs));\n` +
		`  return m;\n` +
		`}\n`
};

let argTypeMap = {
	"": (i) => "",
	// short: (i) => `short a${i};\nJS_ToInt16(ctx, &a${i}, argv[${i}]);\n`,
	int: (i) => `  int a${i};\n  JS_ToInt32(ctx, &a${i}, argv[${i}]);\n`,
	uint: (i) => `  uint a${i};\n  JS_ToUint32(ctx, &a${i}, argv[${i}]);\n`,
	long: (i) => `  long a${i};\n  JS_ToInt64(ctx, &a${i}, argv[${i}]);\n`,
	double: (i) => `  double a${i};\n  JS_ToFloat64(ctx, &a${i}, argv[${i}]);\n`,
	char: (i) => `  const char *a${i} = JS_ToCString(ctx, argv[${i}]);\n`,
	JSValue: (i) => `  JSValue a${i}=argv[${i}];\n`,
	void: (i) => `  void *a${i}=NULL;\n`,
	// 特殊情况
	// JSContext: // 强制为 JSContext * ctx`,
	// JSValueConst: // 不支持
	get "const char"() {
		return this.char;
	}
};
let returnTypeMap = {
	char: (name, arg) => `  return JS_NewString(ctx, ${name}(${arg}));`,
	double: (name, arg) => `  return JS_NewFloat64(ctx, ${name}(${arg}));`,
	int: (name, arg) => `  return JS_NewInt32(ctx, ${name}(${arg}));`,
	// void: (name, arg) => `  return JS_NewInt32(ctx, ${name}(${arg}));`,
};

function getCodeInfo(code) {
	if (!code) return null;
	let text = code;

	return Array.from(text.match(/\n\s*export\s[^\{]+/g) || [])
		// .filter(v => v)
		.map((s, i) => {
			let [prev, arg] = s.replace(/\)\s*\{$/, "").trim()
				.replace(/\s+/g, " ")
				.split("(");

			prev = prev.split(" ").slice(1);
			let name = prev.pop();
			let type = prev.join(" ").replace(/(\s+\*)$/, "");
			arg = arg.replace(/\)$/, "");
			console.log("export:", name + "(", arg, ")=>", type)
			arg = arg.split(",").map(v => {
				v = v.trim().split(" ");
				v.pop();
				return v.join(" ").replace(/(\s+\*)$/, "");
			}).filter(v => !!v); // 类型
			name = name.replace(/^\*/, "");
			let ctxIndex = arg.findIndex(v => v == "JSContext");// ? 'ctx, ' : "";
			let flag = ctxIndex > -1;
			let len = arg.length;
			// console.log("arg1 len", name, len, "|" + arg.join("|") + "|");

			if (flag) arg = arg.filter(v => v != "JSContext");
			// console.log("arg", arg, Array.isArray(arg))
			let jsvalue = (arg).map((v, i) => {
				let fun = argTypeMap[v];
				if (fun) return fun(i);
				console.log("error", "no type", v);
				return "";
			}).join("\n") + "\n";
			let rt = returnTypeMap[type];
			// console.log("arg2 len", name, len, arg);
			if (rt) jsvalue += rt(
				name,
				Array(len).fill(0).map((v, i) => {
					if (flag) {
						if (i == ctxIndex) return "ctx";
						if (i > ctxIndex) i = i - 1;
					}
					return 'a' + i;
				}).join(", ")
			);
			return { name: name, jsvalue: jsvalue, argLen: arg.length, type: type }
		})

}

let compile = fileName.map(src => {
	let fName = src.split("/").pop().split(".");
	let name = fName[0];
	// let type = fName.pop();
	// console.log("name", name, "type", type);
	let text = file(src).read();
	if (text) {
		text = text.replace(/#define export static/g, " ");
		let compile = (("\n" + text).match(/\n\s*#define compile\s+\"([- \w]*)\"\s+/) || ["", ""])[1];
		text = text.replace(/#define compile .+\n/g, "// \n");
		let info = getCodeInfo(text);
		let cFile = `${config.temp}${name}.c`;
		file(cFile).write(code(info, text, name));
		return { name: `${name}`, compile: compile }
	} else {
		console.log("skip", "empty:", `${config.temp}${name}.c`);
		return null;
	}
});
console.log("---------");


let isSuccess = compile.every(v => {
	if (!v) return;
	let gcc = [
		"gcc", `${v.name}.c`,
		"-L", config.qjslib,
		...v.compile.split(" ").filter(v => v),
		"-fPIC", "-shared",
		"-o", `${config.clib}${v.name}.so`, "-w"
	];
	// console.log(`${v.name}.c`, "compile", compile)
	console.log(`build: ${v.name}.c => ${v.name}.so`);
	console.log("       " + gcc.join(" "));
	let status = os.exec(gcc, {
		cwd: config.temp,
		block: true, usePath: true,
	}) == 0

	return status;
});
// console.log("build", isSuccess);
if (isSuccess) {
	console.log(clr.green("build"), "success", "\n---------");
} else {
	console.log(clr.red("exit"));
	std.exit(1);
}